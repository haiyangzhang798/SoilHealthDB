# OC
which(colnames(SoilHealthCC) == 'OC_C')
# N
which(colnames(SoilHealthCC) == 'N_C')
# last useful parameter
which(colnames(SoilHealthCC) == 'MBN_C')
respcol <- c(seq(which(colnames(SoilHealthCC) == 'BiomassCash_C'),which(colnames(SoilHealthCC) == 'OC_C'),5)
,seq(which(colnames(SoilHealthCC) == 'N_C'),which(colnames(SoilHealthCC) == 'MBN_C'),5)) # all response columns
var_climate <- c("Tropical", "Arid", "Temperate", "Boreal")
var_GrainCrop <- c("Corn","Soybean","Wheat", "Vegetable", "CS", "CSW", "Other")
var_CoverCrop <- c("Legume", "Grass", "MTT", "OtherCC")
var_Texture <- c("Coarse", "Medium", "Fine", "NotAvailable")
var_tillage <- c("CT", "RT", "NT", "NotAvailable")
mat <- matrix(NA, ncol=9, nrow=0)
mat <- as.data.frame (mat)
colnames (mat) <- c("ID", "Response", "obs", "Mean", "Low", "High",  "p_UB_Anova", "SubGroup", "TopGroup" )
k = 10000
for (i in 1:length(respcol) ) {
# for (i in 24) {
# i = 2
subdata <- SoilHealthCC[, c(which(colnames(SoilHealthCC) == 'StudyID'|colnames(SoilHealthCC) == 'ExperimentID'|colnames(SoilHealthCC) == 'Tillage_Top_T')
, respcol[i], respcol[i]+1
, which(colnames(SoilHealthCC) == 'Top_Climate'|colnames(SoilHealthCC) == 'TextureGroup'
|colnames(SoilHealthCC) == 'TopCoverCrop'|colnames(SoilHealthCC) == 'TopGrainCrop') )]
subdata <- subdata[!is.na(subdata[,4]), ]
# ============================================ values
val1_response <- colnames(subdata)[4]
val2_n_total <- length(subdata[,1])
subdata$yi <- log(subdata[,5])-log(subdata[,4])
colnames(subdata)
if (colnames (subdata)[4] == "Erosion_C" |colnames (subdata)[4] == "Runoff_C"| colnames (subdata)[4] == "Diseases_C"
| colnames (subdata)[4] == "Leaching_C"| colnames (subdata)[4] == "Weed_C"| colnames (subdata)[4] == "Pests_C")
{
# is.finite(x) value change to min of yi
subdata[is.infinite(subdata$yi),]$yi <- ifelse (subdata[is.infinite(subdata$yi),]$yi>0, max(subdata[is.finite(subdata$yi),]$yi)
, min(subdata[is.finite(subdata$yi),]$yi))
# this line is not necessary anymore because NA has been removed
# if (length(subdata[is.na(subdata$yi),]$yi) > 0) {subdata[is.na(subdata$yi),]$yi <- log(1)}
}
subdata <- subdata[!is.na(subdata$yi),]
# head(subdata, 10)
# hist(subdata$yi, col= "gray", breaks = 20)
# (1) unbalanced ANOVA for ALL data *********************************************************************
# boots and get 95% CI for all
# set.seed(123)
val3_mean_all <- summary(quantile(bootstrap(subdata$yi,k,mean)$thetastar,c(0.025,0.975)) )[4] # get mean value
val4_all_ci_low <- quantile(bootstrap(subdata$yi,k,mean)$thetastar,c(0.025,0.975))[1]
val5_all_ci_high <- quantile(bootstrap(subdata$yi,k,mean)$thetastar,c(0.025,0.975))[2]
submat <- cbind (i, val1_response, val2_n_total, val3_mean_all, val4_all_ci_low, val5_all_ci_high, NA, "All data", "All data")
colnames (submat) <- colnames (mat)
mat <- rbind(mat, submat)
print(paste("**********", i, val1_response, "**********"))
}
for (i in 1:length(respcol) ) {
# for (i in 2) {
# i = 2
subdata <- SoilHealthCC[, c(which(colnames(SoilHealthCC) == 'StudyID'|colnames(SoilHealthCC) == 'ExperimentID'|colnames(SoilHealthCC) == 'Tillage_Top_T')
, respcol[i], respcol[i]+1
, which(colnames(SoilHealthCC) == 'Top_Climate'|colnames(SoilHealthCC) == 'TextureGroup'
|colnames(SoilHealthCC) == 'TopCoverCrop'|colnames(SoilHealthCC) == 'TopGrainCrop') )]
subdata <- subdata[!is.na(subdata[,4]), ]
# ============================================ values
val1_response <- colnames(subdata)[4]
val2_n_total <- length(subdata[,1])
subdata$yi <- log(subdata[,5])-log(subdata[,4])
colnames(subdata)
if (colnames (subdata)[4] == "Erosion_C" |colnames (subdata)[4] == "Runoff_C"| colnames (subdata)[4] == "Diseases_C"
| colnames (subdata)[4] == "Leaching_C"| colnames (subdata)[4] == "Weed_C"| colnames (subdata)[4] == "Pests_C")
{
# is.finite(x) value change to min of yi
subdata[is.infinite(subdata$yi),]$yi <- ifelse (subdata[is.infinite(subdata$yi),]$yi>0, max(subdata[is.finite(subdata$yi),]$yi)
, min(subdata[is.finite(subdata$yi),]$yi))
# this line is not necessary anymore because NA has been removed
# if (length(subdata[is.na(subdata$yi),]$yi) > 0) {subdata[is.na(subdata$yi),]$yi <- log(1)}
}
subdata <- subdata[!is.na(subdata$yi),]
# head(subdata, 10)
# hist(subdata$yi, col= "gray", breaks = 20)
# (2) Unbalaced ANOVA test climate *********************************************************************
# Unbalaced ANOVA
try_anova1 <- try (Anova(lm(yi~Top_Climate,data = subdata), type="III") )
if(inherits(try_anova1, "try-error"))  {
val6_p_UB_anova_climate <- NA
}
else {
val6_p_UB_anova_climate <- round(Anova(lm(yi~Top_Climate,data = subdata), type="III")$`Pr(>F)`[2], 4)
}
# boots and get 95% CI by climate using for loop
# set.seed(123)
# (3) second for loop test climate *********************************************************************
for (j in 1:length(var_climate)) {
# j = 1
sub_climate <- subdata[subdata$Top_Climate == var_climate[j],]
val7_n_climate <- length(sub_climate$yi)
if (val7_n_climate == 0) {
val8_mean_climate <- NA
val9_low_climate<- NA
val10_high_climate <- NA }
else {
val8_mean_climate <- summary(quantile(bootstrap(sub_climate$yi,k,mean)$thetastar,c(0.025,0.975)))[4] # get mean value
val9_low_climate <- quantile(bootstrap(sub_climate$yi,k,mean)$thetastar,c(0.025,0.975))[1]
val10_high_climate <- quantile(bootstrap(sub_climate$yi,k,mean)$thetastar,c(0.025,0.975))[2]
}
mat_climate <- cbind (i, val1_response, val7_n_climate, val8_mean_climate, val9_low_climate, val10_high_climate
, val6_p_UB_anova_climate, var_climate[j], "Climate")
colnames(mat_climate) <- colnames (mat)
mat <- rbind(mat, mat_climate)
print(paste("**********", i, val1_response, "**********", j, var_climate[j], "climate **********"))
}
}
for (i in 1:length(respcol) ) {
# for (i in 2) {
# i = 2
subdata <- SoilHealthCC[, c(which(colnames(SoilHealthCC) == 'StudyID'|colnames(SoilHealthCC) == 'ExperimentID'|colnames(SoilHealthCC) == 'Tillage_Top_T')
, respcol[i], respcol[i]+1
, which(colnames(SoilHealthCC) == 'Top_Climate'|colnames(SoilHealthCC) == 'TextureGroup'
|colnames(SoilHealthCC) == 'TopCoverCrop'|colnames(SoilHealthCC) == 'TopGrainCrop') )]
subdata <- subdata[!is.na(subdata[,4]), ]
# ============================================ values
val1_response <- colnames(subdata)[4]
val2_n_total <- length(subdata[,1])
subdata$yi <- log(subdata[,5])-log(subdata[,4])
colnames(subdata)
if (colnames (subdata)[4] == "Erosion_C" |colnames (subdata)[4] == "Runoff_C"| colnames (subdata)[4] == "Diseases_C"
| colnames (subdata)[4] == "Leaching_C"| colnames (subdata)[4] == "Weed_C"| colnames (subdata)[4] == "Pests_C")
{
# is.finite(x) value change to min of yi
subdata[is.infinite(subdata$yi),]$yi <- ifelse (subdata[is.infinite(subdata$yi),]$yi>0, max(subdata[is.finite(subdata$yi),]$yi)
, min(subdata[is.finite(subdata$yi),]$yi))
# this line is not necessary anymore because NA has been removed
# if (length(subdata[is.na(subdata$yi),]$yi) > 0) {subdata[is.na(subdata$yi),]$yi <- log(1)}
}
subdata <- subdata[!is.na(subdata$yi),]
# head(subdata, 10)
# hist(subdata$yi, col= "gray", breaks = 20)
# (2) Unbalaced ANOVA test Texture *********************************************************************
# Unbalaced ANOVA
try_anova_var <- try (Anova(lm(yi~TextureGroup,data = subdata), type="III") )
if(inherits(try_anova_var, "try-error"))  {
val11_p_UB_anova_var <- NA
}
else {
val11_p_UB_anova_var <- round(Anova(lm(yi~TextureGroup,data = subdata), type="III")$`Pr(>F)`[2], 4)
}
# boots and get 95% CI by Texture using for loop
# set.seed(123)
# (3) usecond for loop test Texture *********************************************************************
for (j in 1:length(var_Texture)) {
# j = 1
sub_var <- subdata[subdata$TextureGroup == var_Texture[j],]
val12_n_var <- length(sub_var$yi)
if (val12_n_var == 0) {
val13_mean_var <- NA
val14_low_var <- NA
val15_high_var <- NA }
else {
val13_mean_var <- summary(quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975)))[4] # get mean value
val14_low_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[1]
val15_high_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[2]
}
mat_var <- cbind (i, val1_response, val12_n_var, val13_mean_var, val14_low_var, val15_high_var
, val11_p_UB_anova_var, var_Texture[j], "Texture")
colnames(mat_var) <- colnames (mat)
mat <- rbind(mat, mat_var)
print(paste("**********", i, val1_response, "**********", j, var_Texture[j], "Texture **********"))
}
}
for (i in 1:length(respcol) ) {
# for (i in 2) {
# i = 2
subdata <- SoilHealthCC[, c(which(colnames(SoilHealthCC) == 'StudyID'|colnames(SoilHealthCC) == 'ExperimentID'|colnames(SoilHealthCC) == 'Tillage_Top_T')
, respcol[i], respcol[i]+1
, which(colnames(SoilHealthCC) == 'Top_Climate'|colnames(SoilHealthCC) == 'TextureGroup'
|colnames(SoilHealthCC) == 'TopCoverCrop'|colnames(SoilHealthCC) == 'TopGrainCrop') )]
subdata <- subdata[!is.na(subdata[,4]), ]
# ============================================ values
val1_response <- colnames(subdata)[4]
val2_n_total <- length(subdata[,1])
subdata$yi <- log(subdata[,5])-log(subdata[,4])
colnames(subdata)
if (colnames (subdata)[4] == "Erosion_C" |colnames (subdata)[4] == "Runoff_C"| colnames (subdata)[4] == "Diseases_C"
| colnames (subdata)[4] == "Leaching_C"| colnames (subdata)[4] == "Weed_C"| colnames (subdata)[4] == "Pests_C")
{
# is.finite(x) value change to min of yi
subdata[is.infinite(subdata$yi),]$yi <- ifelse (subdata[is.infinite(subdata$yi),]$yi>0, max(subdata[is.finite(subdata$yi),]$yi)
, min(subdata[is.finite(subdata$yi),]$yi))
# this line is not necessary anymore because NA has been removed
# if (length(subdata[is.na(subdata$yi),]$yi) > 0) {subdata[is.na(subdata$yi),]$yi <- log(1)}
}
subdata <- subdata[!is.na(subdata$yi),]
# head(subdata, 10)
# hist(subdata$yi, col= "gray", breaks = 20)
# (2) Unbalaced ANOVA test Tillage *********************************************************************
# Unbalaced ANOVA
try_anova_var <- try (Anova(lm(yi~Tillage_Top_T, data = subdata), type="III") )
if(inherits(try_anova_var, "try-error"))  {
val11_p_UB_anova_var <- NA
}
else {
val11_p_UB_anova_var <- round(Anova(lm(yi~Tillage_Top_T,data = subdata), type="III")$`Pr(>F)`[2], 4)
}
# boots and get 95% CI by Texture using for loop
# set.seed(123)
# (3) usecond for loop test Tillage *********************************************************************
for (j in 1:length(var_tillage)) {
# j = 1
sub_var <- subdata[subdata$Tillage_Top_T == var_tillage[j],]
val12_n_var <- length(sub_var$yi)
if (val12_n_var == 0) {
val13_mean_var <- NA
val14_low_var <- NA
val15_high_var <- NA }
else {
val13_mean_var <- summary(quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975)))[4] # get mean value
val14_low_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[1]
val15_high_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[2]
}
mat_var <- cbind (i, val1_response, val12_n_var, val13_mean_var, val14_low_var, val15_high_var
, val11_p_UB_anova_var, var_tillage[j], "Tillage")
colnames(mat_var) <- colnames (mat)
mat <- rbind(mat, mat_var)
print(paste("**********", i, val1_response, "**********", j, var_tillage[j], "Tillage **********"))
}
}
for (i in 1:length(respcol) ) {
# for (i in 2) {
# i = 2
subdata <- SoilHealthCC[, c(which(colnames(SoilHealthCC) == 'StudyID'|colnames(SoilHealthCC) == 'ExperimentID'|colnames(SoilHealthCC) == 'Tillage_Top_T')
, respcol[i], respcol[i]+1
, which(colnames(SoilHealthCC) == 'Top_Climate'|colnames(SoilHealthCC) == 'TextureGroup'
|colnames(SoilHealthCC) == 'TopCoverCrop'|colnames(SoilHealthCC) == 'TopGrainCrop') )]
subdata <- subdata[!is.na(subdata[,4]), ]
# ============================================ values
val1_response <- colnames(subdata)[4]
val2_n_total <- length(subdata[,1])
subdata$yi <- log(subdata[,5])-log(subdata[,4])
colnames(subdata)
if (colnames (subdata)[4] == "Erosion_C" |colnames (subdata)[4] == "Runoff_C"| colnames (subdata)[4] == "Diseases_C"
| colnames (subdata)[4] == "Leaching_C"| colnames (subdata)[4] == "Weed_C"| colnames (subdata)[4] == "Pests_C")
{
# is.finite(x) value change to min of yi
subdata[is.infinite(subdata$yi),]$yi <- ifelse (subdata[is.infinite(subdata$yi),]$yi>0, max(subdata[is.finite(subdata$yi),]$yi)
, min(subdata[is.finite(subdata$yi),]$yi))
# this line is not necessary anymore because NA has been removed
# if (length(subdata[is.na(subdata$yi),]$yi) > 0) {subdata[is.na(subdata$yi),]$yi <- log(1)}
}
subdata <- subdata[!is.na(subdata$yi),]
# head(subdata, 10)
# hist(subdata$yi, col= "gray", breaks = 20)
# (2) Unbalaced ANOVA test Cover crop *********************************************************************
# Unbalaced ANOVA
try_anova_var <- try (Anova(lm(yi~TopCoverCrop, data = subdata), type="III") )
if(inherits(try_anova_var, "try-error"))  {
val11_p_UB_anova_var <- NA
}
else {
val11_p_UB_anova_var <- round(Anova(lm(yi~TopCoverCrop,data = subdata), type="III")$`Pr(>F)`[2], 4)
}
# boots and get 95% CI by Texture using for loop
# set.seed(123)
# (3) usecond for loop test Tillage *********************************************************************
for (j in 1:length(var_CoverCrop)) {
# j = 1
sub_var <- subdata[subdata$TopCoverCrop == var_CoverCrop[j],]
val12_n_var <- length(sub_var$yi)
if (val12_n_var == 0) {
val13_mean_var <- NA
val14_low_var <- NA
val15_high_var <- NA }
else {
val13_mean_var <- summary(quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975)))[4] # get mean value
val14_low_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[1]
val15_high_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[2]
}
mat_var <- cbind (i, val1_response, val12_n_var, val13_mean_var, val14_low_var, val15_high_var
, val11_p_UB_anova_var, var_CoverCrop[j], "Cover crop")
colnames(mat_var) <- colnames (mat)
mat <- rbind(mat, mat_var)
print(paste("**********", i, val1_response, "**********", j, var_CoverCrop[j], "Cover crop **********"))
}
}
for (i in 1:length(respcol) ) {
# for (i in 2) {
# i = 2
subdata <- SoilHealthCC[, c(which(colnames(SoilHealthCC) == 'StudyID'|colnames(SoilHealthCC) == 'ExperimentID'|colnames(SoilHealthCC) == 'Tillage_Top_T')
, respcol[i], respcol[i]+1
, which(colnames(SoilHealthCC) == 'Top_Climate'|colnames(SoilHealthCC) == 'TextureGroup'
|colnames(SoilHealthCC) == 'TopCoverCrop'|colnames(SoilHealthCC) == 'TopGrainCrop') )]
subdata <- subdata[!is.na(subdata[,4]), ]
# ============================================ values
val1_response <- colnames(subdata)[4]
val2_n_total <- length(subdata[,1])
subdata$yi <- log(subdata[,5])-log(subdata[,4])
colnames(subdata)
if (colnames (subdata)[4] == "Erosion_C" |colnames (subdata)[4] == "Runoff_C"| colnames (subdata)[4] == "Diseases_C"
| colnames (subdata)[4] == "Leaching_C"| colnames (subdata)[4] == "Weed_C"| colnames (subdata)[4] == "Pests_C")
{
# is.finite(x) value change to min of yi
subdata[is.infinite(subdata$yi),]$yi <- ifelse (subdata[is.infinite(subdata$yi),]$yi>0, max(subdata[is.finite(subdata$yi),]$yi)
, min(subdata[is.finite(subdata$yi),]$yi))
# this line is not necessary anymore because NA has been removed
# if (length(subdata[is.na(subdata$yi),]$yi) > 0) {subdata[is.na(subdata$yi),]$yi <- log(1)}
}
subdata <- subdata[!is.na(subdata$yi),]
# head(subdata, 10)
# hist(subdata$yi, col= "gray", breaks = 20)
# (2) Unbalaced ANOVA test Cover crop *********************************************************************
# Unbalaced ANOVA
try_anova_var <- try (Anova(lm(yi~TopGrainCrop, data = subdata), type="III") )
if(inherits(try_anova_var, "try-error"))  {
val11_p_UB_anova_var <- NA
}
else {
val11_p_UB_anova_var <- round(Anova(lm(yi~TopGrainCrop,data = subdata), type="III")$`Pr(>F)`[2], 4)
}
# boots and get 95% CI by Texture using for loop
# set.seed(123)
# (3) usecond for loop test Tillage *********************************************************************
for (j in 1:length(var_GrainCrop)) {
# j = 1
sub_var <- subdata[subdata$TopGrainCrop == var_GrainCrop[j],]
val12_n_var <- length(sub_var$yi)
if (val12_n_var == 0) {
val13_mean_var <- NA
val14_low_var <- NA
val15_high_var <- NA }
else {
val13_mean_var <- summary(quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975)))[4] # get mean value
val14_low_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[1]
val15_high_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[2]
}
mat_var <- cbind (i, val1_response, val12_n_var, val13_mean_var, val14_low_var, val15_high_var
, val11_p_UB_anova_var, var_GrainCrop[j], "Grain crop")
colnames(mat_var) <- colnames (mat)
mat <- rbind(mat, mat_var)
print(paste("**********", i, val1_response, "**********", j, var_GrainCrop[j], "***** Grain crop **********"))
}
}
View(mat)
View(mat)
nrow(mat)
mat <- mat[1: nrow(mat) - 7,]
1: nrow(mat) - 7
mat <- mat[1: nrow(mat) - 7,]
for (i in 1:length(respcol) ) {
# for (i in 2) {
# i = 2
subdata <- SoilHealthCC[, c(which(colnames(SoilHealthCC) == 'StudyID'|colnames(SoilHealthCC) == 'ExperimentID'|colnames(SoilHealthCC) == 'Tillage_Top_T')
, respcol[i], respcol[i]+1
, which(colnames(SoilHealthCC) == 'Top_Climate'|colnames(SoilHealthCC) == 'TextureGroup'
|colnames(SoilHealthCC) == 'TopCoverCrop'|colnames(SoilHealthCC) == 'TopGrainCrop') )]
subdata <- subdata[!is.na(subdata[,4]), ]
# ============================================ values
val1_response <- colnames(subdata)[4]
val2_n_total <- length(subdata[,1])
subdata$yi <- log(subdata[,5])-log(subdata[,4])
colnames(subdata)
if (colnames (subdata)[4] == "Erosion_C" |colnames (subdata)[4] == "Runoff_C"| colnames (subdata)[4] == "Diseases_C"
| colnames (subdata)[4] == "Leaching_C"| colnames (subdata)[4] == "Weed_C"| colnames (subdata)[4] == "Pests_C")
{
# is.finite(x) value change to min of yi
subdata[is.infinite(subdata$yi),]$yi <- ifelse (subdata[is.infinite(subdata$yi),]$yi>0, max(subdata[is.finite(subdata$yi),]$yi)
, min(subdata[is.finite(subdata$yi),]$yi))
# this line is not necessary anymore because NA has been removed
# if (length(subdata[is.na(subdata$yi),]$yi) > 0) {subdata[is.na(subdata$yi),]$yi <- log(1)}
}
subdata <- subdata[!is.na(subdata$yi),]
# head(subdata, 10)
# hist(subdata$yi, col= "gray", breaks = 20)
# (2) Unbalaced ANOVA test Cover crop *********************************************************************
# Unbalaced ANOVA
try_anova_var <- try (Anova(lm(yi~TopGrainCrop, data = subdata), type="III") )
if(inherits(try_anova_var, "try-error"))  {
val11_p_UB_anova_var <- NA
}
else {
val11_p_UB_anova_var <- round(Anova(lm(yi~TopGrainCrop,data = subdata), type="III")$`Pr(>F)`[2], 4)
}
# boots and get 95% CI by Texture using for loop
# set.seed(123)
# (3) usecond for loop test Tillage *********************************************************************
for (j in 1:length(var_GrainCrop)) {
# j = 1
sub_var <- subdata[subdata$TopGrainCrop == var_GrainCrop[j],]
val12_n_var <- length(sub_var$yi)
if (val12_n_var == 0) {
val13_mean_var <- NA
val14_low_var <- NA
val15_high_var <- NA }
else {
val13_mean_var <- summary(quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975)))[4] # get mean value
val14_low_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[1]
val15_high_var <- quantile(bootstrap(sub_var$yi,k,mean)$thetastar,c(0.025,0.975))[2]
}
mat_var <- cbind (i, val1_response, val12_n_var, val13_mean_var, val14_low_var, val15_high_var
, val11_p_UB_anova_var, var_GrainCrop[j], "Grain crop")
colnames(mat_var) <- colnames (mat)
mat <- rbind(mat, mat_var)
print(paste("**********", i, val1_response, "**********", j, var_GrainCrop[j], "***** Grain crop **********"))
}
}
View(mat)
data <- read.csv("outputs/SoilHealth_UANOVA_outputs.csv")
# plot UANOVA results
par( mar=c(2, 0.2, 0.2, 0.2)
, mai=c(0.15, 0.6, 0.1, 0.1)  # by inches, inner margin
, omi = c(1.6, 0.3, 0.3, 0.1)  # by inches, outer margin
, mgp = c(0, 0.3, 0) # set distance of axis
, tcl = 0.4
, cex.axis = 1.25
, mfrow=c(1,1))
var_ID <- unique(data$ID)
for (i in 1:length(var_ID)) {
# for (i in 1) {
# i = 2
subdata <- data[data$ID == var_ID[i],]
# subdata$x_value <- c(1,3:4, 6:8, 10:13)
subdata$x_value <- c(1:length(subdata$ID))
y_min <- min(subdata$Low, na.rm = T)
y_max <- max(subdata$High, na.rm = T)
plot(subdata$Mean ~ subdata$x_value, cex=1.25, lwd=2
# ,xlim=c(0,21),ylim=c(1,16)
, las=1
, xaxt='n'
, xlim = c(1, length(subdata$ID))
, ylim = c(y_min, y_max)
, xlab = '', ylab='', main=''
, col = ifelse (subdata$obs < 5, "red", "black")
, pch = ifelse (subdata$obs < 5,4,16)
)
abline(h=0, col="red", lty=2, lwd=2)
arrows(subdata$x_value,subdata$Low,subdata$x_value,subdata$High
,code=3,length=0.0,angle=90,col=ifelse (subdata$obs < 5, "red", "black"),lwd=2)
axis (side = 1, at = subdata$x_value, labels = paste(subdata$SubGroup, " (", subdata$obs, ")", sep = "")
# , cex=0.5
, las = 2
)
# get p value information of each anova
P_climate <- round(subdata[subdata$TopGroup=="Climate",]$p_UB_Anova[2], 4) # climate anoava
P_texture <- round(subdata[subdata$TopGroup=="Texture",]$p_UB_Anova[2], 4) # texture anoava
P_CoverCrop <- round(subdata[subdata$TopGroup=="Cover crop",]$p_UB_Anova[2], 4) # CC anoava
P_GrainCrop <- round(subdata[subdata$TopGroup=="Grain crop",]$p_UB_Anova[2], 4) # Grain crop anoava
# add 2 rectangles
rect(1.5, y_min*ifelse(y_min>0, 0.5, 2), 5.5, y_max*ifelse(y_max<0, 0.1, 2), col= rgb(1,0,0, alpha = 0.5)
, border = rgb(1,0,0, alpha = 0.5))
rect(9.5, y_min*ifelse(y_min>0, 0.5, 2), 13.5, y_max*ifelse(y_max<0, 0.1, 2), col= rgb(1,1,0, alpha = 0.5)
, border = rgb(1,1,0, alpha = 0.5))
axis (side = 3, at = c(1, 3.5, 7.5, 11.5, 17), cex=1.25, labels = c("all", paste("Climate (p=", P_climate, ")", sep = "")
, paste("Texture (p=", P_texture, ")", sep = "")
, paste("Cover crop (p=", P_CoverCrop, ")", sep = "")
, paste("Grain crop (p=", P_GrainCrop, ")", sep = "")  ))
# ?rect()
# add x labels
mtext(side = 2, text = paste(subdata$Response[1], " (Natural log difference)", sep=""), line = -0.25, cex=1.25, outer = T)
}
# Set chunks defaults; these options will be applied to all subsequent chunks
knitr::opts_chunk$set(results = 'hide', message = TRUE, include = TRUE, echo = FALSE, cache = TRUE,
fig.height = 4, fig.width = 8)
# Constants
OUTPUT_DIR		<- "outputs/"
DATA_DIR <- 'data'
# Create output and log folders if they do not exist
if(!file.exists(OUTPUT_DIR)) dir.create(OUTPUT_DIR)
# install.packages('kableExtra')
# Load required packages
library(cowplot)
library(data.table)
library(dplyr)
library(ggplot2)
theme_set(theme_bw())
library(lubridate)
library(kableExtra)
library(cowplot)
library(knitr)
library("ggpubr")
library(reshape)
library(ggplot2)
# install.packages("ggmap")
library(ggmap)
# install.packages("maps")
library(maps)
# install.packages("mapdata")
library(mapdata)
library(tidyr)
library(car)
# install.packages('agricolae')
library(agricolae)
# install.packages('multcompView')
library(multcompView)
library(bootstrap)
library("metafor")
library("bootstrap")
# Source all needed functions
source('RScripts/functions.R')
# load data in
SoilHealthCC <- read.csv('data/SoilHealthDB_V0.csv', header = T)
# remove AFS, Orchard, and pasture
SoilHealthCC %>%
filter(Conservation_Type != "AFS" & Conservation_Type != "Pasture" & Conservation_Type != "Orchard") -> SoilHealthCC
SoilHealthCC$GrainCropGroup <- as.character(SoilHealthCC$GrainCropGroup)
unique(SoilHealthCC$GrainCropGroup)
data <- read.csv("outputs/SoilHealth_UANOVA_outputs.csv")
rm(list=ls())
# plot UANOVA results
par( mar=c(2, 0.2, 0.2, 0.2)
, mai=c(0.15, 0.6, 0.1, 0.1)  # by inches, inner margin
, omi = c(1.6, 0.3, 0.3, 0.1)  # by inches, outer margin
, mgp = c(0, 0.3, 0) # set distance of axis
, tcl = 0.4
, cex.axis = 1.25
, mfrow=c(1,1))
var_ID <- unique(data$ID)
